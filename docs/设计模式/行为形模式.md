### 模版方法模式  
```shell
1. 又叫模版方法，在一个抽象类公开定义了执行它的方法的模版，它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行
2. 模版方法模式的钩子方法：在模版方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为钩子
应用场景：springIoc容器初始化时运用到模版方法模式
注意事项：
    - 1. 算法只存于一个地方，也就是父类中，容易修改，需要修改算法时，只要修改父类的模版方法或已经实现的某些步骤，子类会继承这些修改
    - 2. 实现最大代码复用
    - 3. 模版方法都加上final关键字，防止子类重写模版方法【模板方法是父类几个方法的集合,类似avatar的一键升级包含 安装|配置|启动方法等等 钩子方法指的是子类重写的安装方法】
3. 使用场景：当要完成某个过程，该过程要执行一系列步骤，这一系列步骤基本项目，但其个别步骤实现时可能不同，通常考虑有模版方法模式处理。  
```

### 命令模式
>我们买了一套智能家电，有照明灯、风扇、冰箱、洗衣机，每一种家电都安装一个 App，分别控制， 我们希望只要一个 app 就可以控制全部智能家电。  
要实现一个 app 控制所有智能家电的需要，则每个智能家电厂家都要提供一个统一的接口给 app 调用，这时就可以考虑使用命令模式。  
0. 命令模式,在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，
   我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计
  说白了，先通过Command接口的形式搭建骨架，具体接受者实现Command接口，在运行时候传入调用。底层用接口搭建好框架，上层用接口的实现类传入现实此类方法。
1. **命令模式使用请求发送者与请求接收者消除彼此之间的耦合**，让对象之间的调用关系更加灵活，实现解构。 
2. 在命令模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求，同时**命令模式也支持可测销的操作**。
3. 通俗易懂的理解：将军发布命令，士兵去执行。其中有几个角色：将军（命令发布者）、士兵（命令的具体执行者），命令（连接将军和士兵）
   Invoker是调用者（将军），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象。

优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。  
缺点：使用命令模式可能会导致某些系统有过多的具体命令类。  


### 访问者模式  
访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口    
访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需要避免让这些操作"污染"这些对象的类，可以选用访问者模式解决  
访问者模式优点: 可以对功能进行统一，可以做报表、UI、拦截器与过滤器、适用于数据结构相对稳定的系统      
如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么 访问者模式就是比较合适的  
访问者模式，底层骨架是接口调用接口。 接口A,接口B,在定义各个接口的实现类，这样底层骨架是不用改了。  
```java
A {
    show(B b){
        b.show(this)
    }
}

B ｛
   show(A a)｛
        a.show(this)
     System.out.println("1");
  ｝
｝
```
访问者 与命令模式区别是：   
访问者是 底层骨架搭建好了 接口调用接口.在定义各个接口的实现类，通过骨架完成不同的实现，侧重点在 可以定义多种实现类，可扩展性很强。  
命令模式是。底层骨架搭建好了，但我不知道具体要实现什么，只有在运行的时候最上层最后定义要实现的实现类。侧重点在: 当前具体实现不确定，无法搭建访问者已经确定好的骨架，访问者是业务已经知道了，只为了可扩展，命令模式是业务不知道。搭建个通用的骨架最后进行传入。  



### 迭代器模式   
迭代器模式， 提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构  
迭代器模式解决了 不同集合(ArrayList ,LinkedList) 统一遍历问题  
```shell
    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }
    private class SIterator implements Iterator {
        private int cur;
        public SIterator() {
            this.cur = 0;
        }
        @Override
        public boolean hasNext() {
            return cur < N;
        }
        @Override
        public Object next() {
            return nodes[cur++];
        }
    }
```

### 观察者模式  





